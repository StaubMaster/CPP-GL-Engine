#include "Graphics/Attribute/Base/FloatN.hpp"
#include "OpenGL.hpp"



Attribute::FloatN::FloatN()
{ }
Attribute::FloatN::FloatN(
	unsigned int n,
	GL::AttributeDivisor divisor,
	unsigned int stride,
	GL::AttributeID index
) :	Attribute::Base(),
	Location(GL::AttributeType::Float, sizeof(float) * n, n, divisor, stride, index)
{ }
Attribute::FloatN::~FloatN()
{ }

Attribute::FloatN::FloatN(
	GL::AttributeDivisor divisor,
	unsigned int stride,
	GL::AttributeID index
) :
	Location(GL::AttributeType::Float, sizeof(float), 1, divisor, stride, index)
{ }

Attribute::FloatN::FloatN(const FloatN & other) :
	Attribute::Base(),
	Location(other.Location)
{ }
Attribute::FloatN & Attribute::FloatN::operator=(const FloatN & other)
{
	Attribute::Base::operator=(other);
	//Location = other.Location;
	return *this;
}

#include <iostream>

void Attribute::FloatN::Bind(const unsigned char * & offset) const
{
	int buffer;
std::cerr << __FILE__ << ' ' << __LINE__ << ' ' << GL::GetError() << '\n';
	GL::GetIntegerv(GL::ParameterName::ArrayBufferBinding, buffer);
	std::cout << "Buffer: " << buffer << '\n';
std::cerr << __FILE__ << ' ' << __LINE__ << ' ' << GL::GetError() << '\n';
	GL::EnableVertexAttribArray(Location.Index);
std::cerr << __FILE__ << ' ' << __LINE__ << ' ' << GL::GetError() << '\n';
	std::cout << "Index: " << Location.Index << '\n';
	std::cout << "Count: " << Location.Count << '\n';
	std::cout << "Size: " << Location.Size << '\n';
	std::cout << "Type: " << Location.Type << '\n';
	std::cout << "Stride: " << Location.Stride << '\n';
	std::cout << "offset: " << ((void *)offset) << '\n';
std::cerr << __FILE__ << ' ' << __LINE__ << ' ' << GL::GetError() << '\n';
	GL::VertexAttribPointer(Location.Index, Location.Count, Location.Type, GL_FALSE, Location.Stride, offset);
std::cerr << __FILE__ << ' ' << __LINE__ << ' ' << GL::GetError() << '\n';
	GL::VertexAttribDivisor(Location.Index, Location.Divisor);
std::cerr << __FILE__ << ' ' << __LINE__ << ' ' << GL::GetError() << '\n';
	offset += Location.Size;
}

/*	from Interpolation
src//Graphics/Attribute/Base/FloatN.cpp 43 NoError
Buffer: 4
src//Graphics/Attribute/Base/FloatN.cpp 46 NoError
src//Graphics/Attribute/Base/FloatN.cpp 48 NoError
Index: 5
Count: 2
Size: 8
Type: Float
Stride: 40
offset: 0x20
src//Graphics/Attribute/Base/FloatN.cpp 55 NoError
src//Graphics/Attribute/Base/FloatN.cpp 57 NoError
src//Graphics/Attribute/Base/FloatN.cpp 59 NoError
*/

/*	from scop
src//Graphics/Attribute/Base/FloatN.cpp 43 NoError
Buffer: 2
src//Graphics/Attribute/Base/FloatN.cpp 46 NoError
src//Graphics/Attribute/Base/FloatN.cpp 48 NoError
Index: 11
Count: 3
Size: 12
Type: Float
Stride: 60
offset: 0x30
src//Graphics/Attribute/Base/FloatN.cpp 55 NoError
src//Graphics/Attribute/Base/FloatN.cpp 57 InvalidOperation
src//Graphics/Attribute/Base/FloatN.cpp 59 InvalidOperation
*/

/*	https://registry.khronos.org/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml
Errors
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.
*/

/*
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
size is not GL_BGRA

GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
type is not GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV

GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
type is not GL_UNSIGNED_INT_10F_11F_11F_REV

GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and normalized is GL_FALSE.
size is not GL_BGRA

GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.
the previous GL::Get indicates that zero is not bound to GL_ARRAY_BUFFER
pointer argument is offset, so not NULL

*/
